<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.27">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Bailey Andrew">
<meta name="dcterms.date" content="2023-01-30">
<meta name="description" content="Stride Tricks are Cool!">

<title>Kronecker Sum Projections – Lorem Ipsomething</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
html { -webkit-text-size-adjust: 100%; }
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
/* CSS for citations */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
  margin-bottom: 0em;
}
.hanging-indent div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../../site_libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-dark-4d9afe2b8d18ee9fa5d0d57b5ed4214d.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap-10892d65c249a5d8f93b275ef5a48de5.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="dark">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN" && texText && texText.data) {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="../../styles.css">
<link rel="stylesheet" href="../../html_scripts/collapse.css">
<link rel="stylesheet" href="../../html_scripts/pretty_shortcuts.css">
<meta property="og:title" content="Kronecker Sum Projections – Lorem Ipsomething">
<meta property="og:description" content="Stride Tricks are Cool!">
<meta property="og:image" content="https://BaileyAndrew.github.io/Blog/000_Blog/011_math/images/block-and-stride.jpeg">
<meta property="og:site_name" content="Lorem Ipsomething">
<meta name="twitter:title" content="Kronecker Sum Projections – Lorem Ipsomething">
<meta name="twitter:description" content="Stride Tricks are Cool!">
<meta name="twitter:image" content="https://BaileyAndrew.github.io/Blog/000_Blog/011_math/images/block-and-stride.jpeg">
<meta name="twitter:card" content="summary_large_image">
</head>

<body class="nav-sidebar floating nav-fixed quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">Lorem Ipsomething</span>
    </a>
  </div>
        <div class="quarto-navbar-tools tools-end">
</div>
          <div id="quarto-search" class="" title="Search"></div>
      </div> <!-- /container-fluid -->
    </nav>
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" role="button" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item">Kronecker Sum Projections</li></ol></nav>
        <a class="flex-grow-1" role="navigation" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Home</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../blog.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Blog</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../staticposts.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Static Posts</span></a>
  </div>
</li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" role="navigation" aria-expanded="true">
 <span class="menu-text">Puzzles</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-1" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../500_Puzzles/bnv.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Boulders in Valleys</span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../slideshowindex.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Slideshows</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../otherblogs.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Other People’s Blogs</span></a>
  </div>
</li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#summary" id="toc-summary" class="nav-link active" data-scroll-target="#summary">Summary</a></li>
  <li><a href="#fast-diagonal-kronecker-sum" id="toc-fast-diagonal-kronecker-sum" class="nav-link" data-scroll-target="#fast-diagonal-kronecker-sum">Fast Diagonal <b style="color:#A6A440">Kronecker Sum</b></a></li>
  <li><a href="#ks-decompositions" id="toc-ks-decompositions" class="nav-link" data-scroll-target="#ks-decompositions"><b style="color:#537FBF">KS-Decompositions</b></a></li>
  <li><a href="#playground" id="toc-playground" class="nav-link" data-scroll-target="#playground">Playground</a>
  <ul class="collapse">
  <li><a href="#fast-ks-diag" id="toc-fast-ks-diag" class="nav-link" data-scroll-target="#fast-ks-diag">Fast KS-Diag</a></li>
  </ul></li>
  </ul>
<div class="toc-actions"><ul><li><a href="https://github.com/BaileyAndrew/Blog/issues/new" class="toc-action"><i class="bi bi-github"></i>Report an issue</a></li></ul></div></nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Kronecker Sum Projections</h1>
  <div class="quarto-categories">
    <div class="quarto-category">Work</div>
    <div class="quarto-category">Useful</div>
    <div class="quarto-category">Vroomy Code</div>
  </div>
  </div>

<div>
  <div class="description">
    Stride Tricks are Cool!
  </div>
</div>


<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Bailey Andrew </p>
          </div>
  </div>
    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">January 30, 2023</p>
    </div>
  </div>
  
    
  </div>
  


</header>


<!-- WARNING: THIS FILE WAS AUTOGENERATED! DO NOT EDIT! -->
<section id="summary" class="level1">
<h1>Summary</h1>
<p>In my work I have to deal with <b style="color:#A6A440">Kronecker Sums</b> a lot; these are ultimately built out of <b style="color:#A6A440">Kronecker Products</b>, which are represented by <span class="math inline">\(\otimes\)</span> work like this:</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="./images/block-and-stride.jpeg" class="img-fluid figure-img"></p>
<figcaption>Two ways of thinking about <b style="color:#A6A440">Kronecker Products</b></figcaption>
</figure>
</div>
<p><b style="color:#A6A440">Kronecker Sums</b> are represented by <span class="math inline">\(\oplus\)</span> and are defined as <span class="math inline">\(A \oplus B = A \otimes I + I \otimes B\)</span>. They have a convenient property that allows us to factor out eigenvectors: <span class="math inline">\(A \oplus B = \left(V_A \otimes V_B\right)\left(\Lambda_A \oplus \Lambda_B\right)\left(V_A^T \otimes V_B^T\right)\)</span>, which means that for most things I only need to consider the <b style="color:#A6A440">Kronecker Sum</b> of diagonal matrices.</p>
<p>In my work I have two coding problems related to this task:</p>
<ol type="1">
<li>Finding a fast algorithm for the <b style="color:#A6A440">Kronecker Sum</b> of many diagonal matrices</li>
<li>Finding a fast algorithm to <b style="color:#537FBF">KS-decompose</b> a diagonal matrix</li>
</ol>
<p>By <b style="color:#537FBF">KS-decompose</b>, I mean to represent a matrix as a <b style="color:#A6A440">Kronecker Sum</b> of other matrices of a given size. Most matrices are not perfectly <b style="color:#537FBF">KS-decomposable</b>; specifically we want the decomposition that minimizes the <b style="color:#EB1960">Frobenius Distance</b> between the original matrix and the proposed decomposition. We won’t go over the specifics of <b style="color:#EB1960">Frobenius Distance</b>, but it’s basically the matrix analog for the <b style="color:#EB1960">Euclidean Distance</b> between vectors.</p>
<p><span class="citation" data-cites="TeraLasso">Greenewald, Zhou, and Hero (<a href="#ref-TeraLasso" role="doc-biblioref">2017</a>)</span> have already given an analytic formula for the <b style="color:#537FBF">KS-decomposition</b>, which we’ll use later. But we’ll tackle the <b style="color:#A6A440">Kronecker Sum</b> algorithm first.</p>
</section>
<section id="fast-diagonal-kronecker-sum" class="level1">
<h1>Fast Diagonal <b style="color:#A6A440">Kronecker Sum</b></h1>
<div id="fda672a1-5816-4f34-a9e4-4096d8594120" class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</div>
<p>There is a function <code>scipy.sparse.kronsum</code> which may be useful, but I’ve had problems with the <code>sparse</code> library in the past so I’ll wait until its a bit more mature before I’ll consider relying on it. Furthermore, it probably won’t be very useful for diagonal <b style="color:#A6A440">Kronecker Sums</b> because it will have been built for a whole <b style="color:#A6A440">Kronecker Sum</b>.</p>
<p>By the way, here’s how you would do a whole <b style="color:#A6A440">Kronecker Sum</b>:</p>
<div id="395821c6-744a-4fe6-b507-c6b5f051a535" class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb2"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> kron_sum_base_case(</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>    A: <span class="st">"A 2-dimensional square numpy array of any size"</span>,</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>    B: <span class="st">"A 2-dimensional square numpy array of any size"</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>) <span class="op">-&gt;</span> <span class="st">"kronsum(A, B)"</span>:</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a><span class="co">    Computes the kronsum of two square input matrices</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>    a, _ <span class="op">=</span> A.shape</span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>    b, _ <span class="op">=</span> B.shape</span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> np.kron(A, np.eye(b)) <span class="op">+</span> np.kron(np.eye(a), B)</span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> kron_sum(</span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a>    <span class="op">*</span>mats: <span class="st">"Sequence of 2-dimensional square numpy arrays of any size"</span></span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a>) <span class="op">-&gt;</span> <span class="st">"kronsum(mats[0], ..., mats[-1])"</span>:</span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a><span class="co">    Computes the kronsum of multiple matrices,</span></span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true" tabindex="-1"></a><span class="co">    recursively by relying on `kron_sum_base_case`</span></span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true" tabindex="-1"></a><span class="co">    for the 2-matrix case</span></span>
<span id="cb2-19"><a href="#cb2-19" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb2-20"><a href="#cb2-20" aria-hidden="true" tabindex="-1"></a>    K <span class="op">=</span> <span class="bu">len</span>(mats)</span>
<span id="cb2-21"><a href="#cb2-21" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> K <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb2-22"><a href="#cb2-22" aria-hidden="true" tabindex="-1"></a>        <span class="cf">raise</span> <span class="pp">Exception</span>(<span class="st">"Can't kronsum nothing!"</span>)</span>
<span id="cb2-23"><a href="#cb2-23" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> K <span class="op">==</span> <span class="dv">1</span>:</span>
<span id="cb2-24"><a href="#cb2-24" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> mats[<span class="dv">0</span>]</span>
<span id="cb2-25"><a href="#cb2-25" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> K <span class="op">==</span> <span class="dv">2</span>:</span>
<span id="cb2-26"><a href="#cb2-26" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> kron_sum_base_case(mats[<span class="dv">0</span>], mats[<span class="dv">1</span>])</span>
<span id="cb2-27"><a href="#cb2-27" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> kron_sum(</span>
<span id="cb2-28"><a href="#cb2-28" aria-hidden="true" tabindex="-1"></a>        kron_sum_base_case(mats[<span class="dv">0</span>], mats[<span class="dv">1</span>]),</span>
<span id="cb2-29"><a href="#cb2-29" aria-hidden="true" tabindex="-1"></a>        <span class="op">*</span>mats[<span class="dv">2</span>:]</span>
<span id="cb2-30"><a href="#cb2-30" aria-hidden="true" tabindex="-1"></a>    )</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</div>
<p>Of course, for diagonal matrices we can do better by observing the pattern of repetitions of the diagonal elements.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="./images/ks-example.jpeg" class="img-fluid figure-img"></p>
<figcaption>There is a pattern: it is the sum of repetitions in blocks and repetitions in strides</figcaption>
</figure>
</div>
<p>We can incorporate this into our code:</p>
<div id="148de210-dd81-4453-b5ea-c6a2bb1415ef" class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb3"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> kron_sum_diag_base_case(</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>    a: <span class="st">"NumPy vector of shape (m,)"</span>,</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>    b: <span class="st">"NumPy vector of shape (n,)"</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>) <span class="op">-&gt;</span> <span class="st">"NumPy vector of shape (mn,)"</span>:</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a><span class="co">    Computes the diagonal of the kronecker sum of two diagonal matrixes,</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a><span class="co">    given as input the diagonals of the two input matrices</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>    m, <span class="op">=</span> a.shape</span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>    n, <span class="op">=</span> b.shape</span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Result is sum of [a1 ... a1 a2 ... a2 ... am ... am]</span></span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a>    <span class="co"># and [b1 b2 ... bn b1 b2 ... bn ... b1 b2 ... bn]</span></span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a>    <span class="co"># So we can use `repeat` and `tile` to accomplish this!</span></span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a>    A <span class="op">=</span> np.repeat(a, (n,))</span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a>    B <span class="op">=</span> np.tile(b, (m,))</span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> (A <span class="op">+</span> B)</span>
<span id="cb3-18"><a href="#cb3-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-19"><a href="#cb3-19" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> kron_sum_diag(</span>
<span id="cb3-20"><a href="#cb3-20" aria-hidden="true" tabindex="-1"></a>    <span class="op">*</span>vecs: <span class="st">"Sequence of NumPy vectors representing array diagonals"</span></span>
<span id="cb3-21"><a href="#cb3-21" aria-hidden="true" tabindex="-1"></a>) <span class="op">-&gt;</span> <span class="st">"diag(kronsum(diag(vecs[0]), ..., diag(vecs[-1])))"</span>:</span>
<span id="cb3-22"><a href="#cb3-22" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb3-23"><a href="#cb3-23" aria-hidden="true" tabindex="-1"></a><span class="co">    Computes the kronsum of multiple vectors,</span></span>
<span id="cb3-24"><a href="#cb3-24" aria-hidden="true" tabindex="-1"></a><span class="co">    recursively by relying on `kron_sum_diag_base_case`</span></span>
<span id="cb3-25"><a href="#cb3-25" aria-hidden="true" tabindex="-1"></a><span class="co">    for the 2-vector case</span></span>
<span id="cb3-26"><a href="#cb3-26" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb3-27"><a href="#cb3-27" aria-hidden="true" tabindex="-1"></a>    K <span class="op">=</span> <span class="bu">len</span>(vecs)</span>
<span id="cb3-28"><a href="#cb3-28" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> K <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb3-29"><a href="#cb3-29" aria-hidden="true" tabindex="-1"></a>        <span class="cf">raise</span> <span class="pp">Exception</span>(<span class="st">"Can't kronsum nothing!"</span>)</span>
<span id="cb3-30"><a href="#cb3-30" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> K <span class="op">==</span> <span class="dv">1</span>:</span>
<span id="cb3-31"><a href="#cb3-31" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> vecs[<span class="dv">0</span>]</span>
<span id="cb3-32"><a href="#cb3-32" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> K <span class="op">==</span> <span class="dv">2</span>:</span>
<span id="cb3-33"><a href="#cb3-33" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> kron_sum_diag_base_case(vecs[<span class="dv">0</span>], vecs[<span class="dv">1</span>])</span>
<span id="cb3-34"><a href="#cb3-34" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> kron_sum_diag(</span>
<span id="cb3-35"><a href="#cb3-35" aria-hidden="true" tabindex="-1"></a>        kron_sum_diag_base_case(vecs[<span class="dv">0</span>], vecs[<span class="dv">1</span>]),</span>
<span id="cb3-36"><a href="#cb3-36" aria-hidden="true" tabindex="-1"></a>        <span class="op">*</span>vecs[<span class="dv">2</span>:]</span>
<span id="cb3-37"><a href="#cb3-37" aria-hidden="true" tabindex="-1"></a>    )</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</div>
<p>Let’s compare them using <code>line_profiler</code>: it only runs the code once so in theory it shouldn’t be used for rigorous comparisons, but the difference should be clear between the two and the output is so much more informative:</p>
<div id="db563c8d-1e06-446d-99ff-8de8310a3332" class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb4"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>args <span class="op">=</span> [</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>    np.diag(np.arange(<span class="dv">10</span>)),</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>    np.diag(np.arange(<span class="dv">10</span>)),</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>    np.diag(np.arange(<span class="dv">10</span>))</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>]</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-display">
<pre><code>Timer unit: 1e-06 s

Total time: 0.020624 s
File: /var/folders/k0/qy74mdx10qs493700g929k5h0000gn/T/ipykernel_36281/668194435.py
Function: kron_sum_base_case at line 1

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
     1                                           def kron_sum_base_case(
     2                                               A: "A 2-dimensional square numpy array of any size",
     3                                               B: "A 2-dimensional square numpy array of any size"
     4                                           ) -&gt; "kronsum(A, B)":
     5                                               """
     6                                               Computes the kronsum of two square input matrices
     7                                               """
     8         2        236.0    118.0      1.1      a, _ = A.shape
     9         2          6.0      3.0      0.0      b, _ = B.shape
    10         2      20382.0  10191.0     98.8      return np.kron(A, np.eye(b)) + np.kron(np.eye(a), B)

Total time: 0.021422 s
File: /var/folders/k0/qy74mdx10qs493700g929k5h0000gn/T/ipykernel_36281/668194435.py
Function: kron_sum at line 12

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
    12                                           def kron_sum(
    13                                               *mats: "Sequence of 2-dimensional square numpy arrays of any size"
    14                                           ) -&gt; "kronsum(mats[0], ..., mats[-1])":
    15                                               """
    16                                               Computes the kronsum of multiple matrices,
    17                                               recursively by relying on `kron_sum_base_case`
    18                                               for the 2-matrix case
    19                                               """
    20         2        215.0    107.5      1.0      K = len(mats)
    21         2        169.0     84.5      0.8      if K == 0:
    22                                                   raise Exception("Can't kronsum nothing!")
    23         2          4.0      2.0      0.0      if K == 1:
    24                                                   return mats[0]
    25         2          3.0      1.5      0.0      if K == 2:
    26         1      15203.0  15203.0     71.0          return kron_sum_base_case(mats[0], mats[1])
    27         3         80.0     26.7      0.4      return kron_sum(
    28         1       5743.0   5743.0     26.8          kron_sum_base_case(mats[0], mats[1]),
    29         1          5.0      5.0      0.0          *mats[2:]
    30                                               )</code></pre>
</div>
</div>
<div id="7a9e371d-d1ec-4202-ae11-65272ad7f4d2" class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb6"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>args <span class="op">=</span> [</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>    np.arange(<span class="dv">10</span>),</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>    np.arange(<span class="dv">10</span>),</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>    np.arange(<span class="dv">10</span>)</span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>]</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-display">
<pre><code>Timer unit: 1e-06 s

Total time: 0.000238 s
File: /var/folders/k0/qy74mdx10qs493700g929k5h0000gn/T/ipykernel_36281/2323241970.py
Function: kron_sum_diag_base_case at line 1

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
     1                                           def kron_sum_diag_base_case(
     2                                               a: "NumPy vector of shape (m,)",
     3                                               b: "NumPy vector of shape (n,)"
     4                                           ) -&gt; "NumPy vector of shape (mn,)":
     5                                               """
     6                                               Computes the diagonal of the kronecker sum of two diagonal matrixes,
     7                                               given as input the diagonals of the two input matrices
     8                                               """
     9         2          5.0      2.5      2.1      m, = a.shape
    10         2          2.0      1.0      0.8      n, = b.shape
    11                                               
    12                                               # Result is sum of [a1 ... a1 a2 ... a2 ... am ... am]
    13                                               # and [b1 b2 ... bn b1 b2 ... bn ... b1 b2 ... bn]
    14                                               # So we can use `repeat` and `tile` to accomplish this!
    15         2         78.0     39.0     32.8      A = np.repeat(a, (n,))
    16         2        116.0     58.0     48.7      B = np.tile(b, (m,))
    17         2         37.0     18.5     15.5      return (A + B)

Total time: 0.000317 s
File: /var/folders/k0/qy74mdx10qs493700g929k5h0000gn/T/ipykernel_36281/2323241970.py
Function: kron_sum_diag at line 19

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
    19                                           def kron_sum_diag(
    20                                               *vecs: "Sequence of NumPy vectors representing array diagonals"
    21                                           ) -&gt; "diag(kronsum(diag(vecs[0]), ..., diag(vecs[-1])))":
    22                                               """
    23                                               Computes the kronsum of multiple vectors,
    24                                               recursively by relying on `kron_sum_diag_base_case`
    25                                               for the 2-vector case
    26                                               """
    27         2          9.0      4.5      2.8      K = len(vecs)
    28         2          5.0      2.5      1.6      if K == 0:
    29                                                   raise Exception("Can't kronsum nothing!")
    30         2          1.0      0.5      0.3      if K == 1:
    31                                                   return vecs[0]
    32         2          2.0      1.0      0.6      if K == 2:
    33         1         89.0     89.0     28.1          return kron_sum_diag_base_case(vecs[0], vecs[1])
    34         3         37.0     12.3     11.7      return kron_sum_diag(
    35         1        171.0    171.0     53.9          kron_sum_diag_base_case(vecs[0], vecs[1]),
    36         1          3.0      3.0      0.9          *vecs[2:]
    37                                               )</code></pre>
</div>
</div>
<p>Other than speed, a major problem with the non-diag-specific code is that you’ll run out of memory for even modestly sized outputs: <span class="math inline">\(\mathrm{numrows}\left[\oplus_\ell A_\ell \right] = \prod_\ell \mathrm{numrows}\left[A_\ell \right]\)</span>. When modelling the whole matrix, you need to store <span class="math inline">\(\prod_\ell \mathrm{numrows}\left[A_\ell \right]^2\)</span>, but by restricting ourselves to the diagonal you only need <span class="math inline">\(\prod_\ell \mathrm{numrows}\left[A_\ell \right]\)</span>.</p>
<p>We can see from the outputs of <code>line_profiler</code> that the grand majority of the runtime is spent in <code>np.repeat</code> and <code>np.tile</code>, so we might wish to find a solution that does not require these. Also, the recursive nature of the algorithm is a bit annoying, it’d be nice if we could compute it in a single pass!</p>
<p>For this we’ll need to understand the <b style="color:#EB1960">NumPy Memory Model</b>, which consists of <b style="color:#A6A440">shapes</b> and <b style="color:#A6A440">strides</b>:</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="./images/memory-model.png" class="img-fluid figure-img"></p>
<figcaption>The <b style="color:#EB1960">NumPy Memory Model</b></figcaption>
</figure>
</div>
<p>In essence, <strong style="color:#C0CF96">every array is actually linear in memory</strong>, and we describe the higher-dimensional structure with a <b style="color:#A6A440">shape</b> and some <b style="color:#A6A440">strides</b>. <b style="color:#A6A440">Strides</b> tell us how far our pointer must move to get to the next element along that axis.</p>
<p>Changing the <b style="color:#A6A440">shape</b> and <b style="color:#A6A440">strides</b> of an array is basically free, as none of the array’s memory needs to change<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>. <code>np.lib.stride_tricks.as_strided</code> is a function that gives us direct control over <b style="color:#A6A440">shape</b> and <b style="color:#A6A440">strides</b>, which we’ll use to construct a faster <b style="color:#A6A440">Kronecker Sum</b> algorithm.</p>
<p>The first thing we want to do is create a full-sized empty output vector with <code>np.zeros</code>. We’ll then reshape this vector in such a way so that the elements we want to affect are batched by the first two dimensions. Why would we do this? Because numpy’s memory format doesn’t directly support “block-strides”, i.e.&nbsp;there’s no direct way to grab:</p>
<pre><code>[x x x x] x x x x [x x x x] x x x x</code></pre>
<p>You can only either grab blocks:</p>
<pre><code>[x x x x x x x x] x x x x x x x x</code></pre>
<p>Or strides:</p>
<pre><code>[x] x [x] x [x] x [x] x [x] x [x] x [x] x [x] x [x] x [x] x</code></pre>
<p>But with stride_tricks we can massage the data into a block-stride format, at the cost of an extra dimension, via using a <b style="color:#A6A440">view</b> (NOT a <b style="color:#A6A440">copy</b>), making this quite an efficient operation! Since it is a view, <strong style="color:#C0CF96">we can assign to it and it will update the original array.</strong></p>
<p>Suppose we reshaped our output <span class="math inline">\(w_\ell\)</span> into <span class="math inline">\((a_\ell, b_\ell, c_\ell)\)</span> where <span class="math inline">\(c_\ell\)</span> is the size of our <span class="math inline">\(\ell\)</span>th input <span class="math inline">\(v_\ell\)</span>. Then <span class="math inline">\(w_\ell += v_\ell\)</span> will use <b style="color:#537FBF">broadcasting</b><a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a> to add <span class="math inline">\(v_\ell\)</span> to every slice of the matrix along the first two batch dimensions.</p>
<p>Why would we do this? Well just like we saw earlier, <b style="color:#A6A440">Kronecker Sums</b> can be represented as the sum of one of the inputs repeated in blocks and the other repeated in strides, when only considering two inputs. When considering the middle inputs, they have a particular block-strided structure; I encourage you to get out some scratch paper and work it out yourself.</p>
<p>Anyways, here’s the code:</p>
<div id="7a773ea4-d115-4b14-9dc6-fcd8ebed9f36" class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb11"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> kron_sum_diag_fast(</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>    <span class="op">*</span>lams: <span class="st">"1D vectors to be kronsummed"</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>):</span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Setup</span></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>    ds <span class="op">=</span> [<span class="bu">len</span>(lam) <span class="cf">for</span> lam <span class="kw">in</span> lams]</span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>    d_lefts <span class="op">=</span> np.cumprod([<span class="dv">1</span>] <span class="op">+</span> ds[:<span class="op">-</span><span class="dv">1</span>]).astype(<span class="bu">int</span>)</span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a>    d_rights <span class="op">=</span> np.cumprod([<span class="dv">1</span>] <span class="op">+</span> ds[::<span class="op">-</span><span class="dv">1</span>])[<span class="op">-</span><span class="dv">2</span>::<span class="op">-</span><span class="dv">1</span>].astype(<span class="bu">int</span>)</span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a>    total <span class="op">=</span> d_rights[<span class="dv">0</span>] <span class="op">*</span> ds[<span class="dv">0</span>]</span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a>    out <span class="op">=</span> np.zeros(total)</span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true" tabindex="-1"></a>    <span class="co"># We're gonna be really naughty here and use stride_tricks</span></span>
<span id="cb11-12"><a href="#cb11-12" aria-hidden="true" tabindex="-1"></a>    <span class="co"># This is going to reshape our vector in a way so that the elements</span></span>
<span id="cb11-13"><a href="#cb11-13" aria-hidden="true" tabindex="-1"></a>    <span class="co"># we want to affect are batched by the first two dimensions</span></span>
<span id="cb11-14"><a href="#cb11-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(lams)):</span>
<span id="cb11-15"><a href="#cb11-15" aria-hidden="true" tabindex="-1"></a>        sz <span class="op">=</span> lams[i].strides[<span class="dv">0</span>]</span>
<span id="cb11-16"><a href="#cb11-16" aria-hidden="true" tabindex="-1"></a>        toset <span class="op">=</span> np.lib.stride_tricks.as_strided(</span>
<span id="cb11-17"><a href="#cb11-17" aria-hidden="true" tabindex="-1"></a>            out,</span>
<span id="cb11-18"><a href="#cb11-18" aria-hidden="true" tabindex="-1"></a>            shape<span class="op">=</span>(</span>
<span id="cb11-19"><a href="#cb11-19" aria-hidden="true" tabindex="-1"></a>                d_lefts[i], <span class="co"># The skips</span></span>
<span id="cb11-20"><a href="#cb11-20" aria-hidden="true" tabindex="-1"></a>                d_rights[i], <span class="co"># The blocks</span></span>
<span id="cb11-21"><a href="#cb11-21" aria-hidden="true" tabindex="-1"></a>                ds[i] <span class="co"># What we want</span></span>
<span id="cb11-22"><a href="#cb11-22" aria-hidden="true" tabindex="-1"></a>            ),</span>
<span id="cb11-23"><a href="#cb11-23" aria-hidden="true" tabindex="-1"></a>            strides<span class="op">=</span>(</span>
<span id="cb11-24"><a href="#cb11-24" aria-hidden="true" tabindex="-1"></a>                sz <span class="op">*</span> ds[i] <span class="op">*</span> d_rights[i],</span>
<span id="cb11-25"><a href="#cb11-25" aria-hidden="true" tabindex="-1"></a>                sz <span class="op">*</span> <span class="dv">1</span>,</span>
<span id="cb11-26"><a href="#cb11-26" aria-hidden="true" tabindex="-1"></a>                sz <span class="op">*</span> d_rights[i],</span>
<span id="cb11-27"><a href="#cb11-27" aria-hidden="true" tabindex="-1"></a>            )</span>
<span id="cb11-28"><a href="#cb11-28" aria-hidden="true" tabindex="-1"></a>        )</span>
<span id="cb11-29"><a href="#cb11-29" aria-hidden="true" tabindex="-1"></a>        toset <span class="op">+=</span> lams[i]</span>
<span id="cb11-30"><a href="#cb11-30" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb11-31"><a href="#cb11-31" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> out</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</div>
<p>Let’s see if it’s really any faster:</p>
<div id="9f208d4f-e94e-4d7c-8bbf-5b319cc65697" class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb12"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>args <span class="op">=</span> [</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>    np.arange(<span class="dv">100</span>),</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>    np.arange(<span class="dv">100</span>),</span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>    np.arange(<span class="dv">100</span>)</span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>]</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-display">
<pre><code>Timer unit: 1e-06 s

Total time: 0.027999 s
File: /var/folders/k0/qy74mdx10qs493700g929k5h0000gn/T/ipykernel_36281/2323241970.py
Function: kron_sum_diag_base_case at line 1

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
     1                                           def kron_sum_diag_base_case(
     2                                               a: "NumPy vector of shape (m,)",
     3                                               b: "NumPy vector of shape (n,)"
     4                                           ) -&gt; "NumPy vector of shape (mn,)":
     5                                               """
     6                                               Computes the diagonal of the kronecker sum of two diagonal matrixes,
     7                                               given as input the diagonals of the two input matrices
     8                                               """
     9         2         13.0      6.5      0.0      m, = a.shape
    10         2          3.0      1.5      0.0      n, = b.shape
    11                                               
    12                                               # Result is sum of [a1 ... a1 a2 ... a2 ... am ... am]
    13                                               # and [b1 b2 ... bn b1 b2 ... bn ... b1 b2 ... bn]
    14                                               # So we can use `repeat` and `tile` to accomplish this!
    15         2      19483.0   9741.5     69.6      A = np.repeat(a, (n,))
    16         2       1027.0    513.5      3.7      B = np.tile(b, (m,))
    17         2       7473.0   3736.5     26.7      return (A + B)

Total time: 0.028123 s
File: /var/folders/k0/qy74mdx10qs493700g929k5h0000gn/T/ipykernel_36281/2323241970.py
Function: kron_sum_diag at line 19

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
    19                                           def kron_sum_diag(
    20                                               *vecs: "Sequence of NumPy vectors representing array diagonals"
    21                                           ) -&gt; "diag(kronsum(diag(vecs[0]), ..., diag(vecs[-1])))":
    22                                               """
    23                                               Computes the kronsum of multiple vectors,
    24                                               recursively by relying on `kron_sum_diag_base_case`
    25                                               for the 2-vector case
    26                                               """
    27         2         11.0      5.5      0.0      K = len(vecs)
    28         2          5.0      2.5      0.0      if K == 0:
    29                                                   raise Exception("Can't kronsum nothing!")
    30         2          2.0      1.0      0.0      if K == 1:
    31                                                   return vecs[0]
    32         2          2.0      1.0      0.0      if K == 2:
    33         1      27184.0  27184.0     96.7          return kron_sum_diag_base_case(vecs[0], vecs[1])
    34         3          8.0      2.7      0.0      return kron_sum_diag(
    35         1        906.0    906.0      3.2          kron_sum_diag_base_case(vecs[0], vecs[1]),
    36         1          5.0      5.0      0.0          *vecs[2:]
    37                                               )</code></pre>
</div>
</div>
<div id="1461f536-5524-4a1a-8341-375780758e11" class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb14"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a>args <span class="op">=</span> [</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>    np.arange(<span class="dv">100</span>),</span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>    np.arange(<span class="dv">100</span>),</span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>    np.arange(<span class="dv">100</span>)</span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a>]</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-display">
<pre><code>Timer unit: 1e-06 s

Total time: 0.008428 s
File: /var/folders/k0/qy74mdx10qs493700g929k5h0000gn/T/ipykernel_36281/219179398.py
Function: kron_sum_diag_fast at line 1

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
     1                                           def kron_sum_diag_fast(
     2                                               *lams: "1D vectors to be kronsummed"
     3                                           ):
     4                                               # Setup
     5         1         19.0     19.0      0.2      ds = [len(lam) for lam in lams]
     6         1        188.0    188.0      2.2      d_lefts = np.cumprod([1] + ds[:-1]).astype(int)
     7         1         68.0     68.0      0.8      d_rights = np.cumprod([1] + ds[::-1])[-2::-1].astype(int)
     8         1         16.0     16.0      0.2      total = d_rights[0] * ds[0]
     9         1       1990.0   1990.0     23.6      out = np.zeros(total)
    10                                               
    11                                               # We're gonna be really naughty here and use stride_tricks
    12                                               # This is going to reshape our vector in a way so that the elements
    13                                               # we want to affect are batched by the first two dimensions
    14         4         42.0     10.5      0.5      for i in range(len(lams)):
    15         3         25.0      8.3      0.3          sz = lams[i].strides[0]
    16         6        416.0     69.3      4.9          toset = np.lib.stride_tricks.as_strided(
    17         3          6.0      2.0      0.1              out,
    18         3          9.0      3.0      0.1              shape=(
    19         3         29.0      9.7      0.3                  d_lefts[i], # The skips
    20         3         21.0      7.0      0.2                  d_rights[i], # The blocks
    21         3          8.0      2.7      0.1                  ds[i] # What we want
    22                                                       ),
    23         3          5.0      1.7      0.1              strides=(
    24         3         22.0      7.3      0.3                  sz * ds[i] * d_rights[i],
    25         3          6.0      2.0      0.1                  sz * 1,
    26         3          8.0      2.7      0.1                  sz * d_rights[i],
    27                                                       )
    28                                                   )
    29         3       5548.0   1849.3     65.8          toset += lams[i]
    30                                                   
    31         1          2.0      2.0      0.0      return out</code></pre>
</div>
</div>
<p>Honestly, it’s hard to tell. If we rerun the code a bit then the values fluctuate. They seem to on average be more expensive for the non-fast version of the algorithm, but we should use timeit to fully compare:</p>
<div id="8cde2ab2-bd80-4484-9d8f-e9f0fed23919" class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb16"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a>args <span class="op">=</span> [</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>    np.arange(<span class="dv">100</span>),</span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>    np.arange(<span class="dv">100</span>),</span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a>    np.arange(<span class="dv">100</span>)</span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a>]</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-stdout">
<pre><code>4.19 ms ± 132 µs per loop (mean ± std. dev. of 7 runs, 100 loops each)
1.31 ms ± 5.04 µs per loop (mean ± std. dev. of 7 runs, 1,000 loops each)</code></pre>
</div>
</div>
<p>With how much more conceptually complicated the fast version is, it’s a bit of a shame that it only really achieves a 3x speedup. Maybe things will look better with larger inputs? But it’s hard to test large inputs without running out of memory.</p>
<div id="6472ef73-507f-4086-aaee-4ca30cc79625" class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb18"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a>args <span class="op">=</span> [</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>    np.arange(<span class="dv">1000</span>),</span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>    np.arange(<span class="dv">100</span>),</span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a>    np.arange(<span class="dv">100</span>)</span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a>]</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-stdout">
<pre><code>47.5 ms ± 3.18 ms per loop (mean ± std. dev. of 7 runs, 10 loops each)
15.3 ms ± 321 µs per loop (mean ± std. dev. of 7 runs, 100 loops each)</code></pre>
</div>
</div>
<div id="75e73030-8146-45d1-84fa-2fc1c47cf183" class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb20"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a>args <span class="op">=</span> [</span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>    np.arange(<span class="dv">10000</span>),</span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a>    np.arange(<span class="dv">10000</span>)</span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a>]</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-stdout">
<pre><code>1.53 s ± 47.8 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)
350 ms ± 2.08 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)</code></pre>
</div>
</div>
<p><code>kron_sum_diag_fast</code> is definitely an improvement, but not quite the order-of-magnitude improvement I was hoping for! Based on the outputs of <code>line_profiler</code>, ~90% of the runtime of <code>kron_sum_diag_fast</code> comes from the memory allocation of the output vector and the literal summing of the diagonals. It is unlikely to be able to go much faster - in fact no matter what we do we cannot make it more than 4x faster because the memory allocation of the output takes ~25% of the runtime.</p>
</section>
<section id="ks-decompositions" class="level1">
<h1><b style="color:#537FBF">KS-Decompositions</b></h1>
<p>We now start our second task; finding the best <b style="color:#537FBF">KS-decomposition</b> for a matrix.</p>
<p>The mathematical solution is due to <span class="citation" data-cites="TeraLasso">Greenewald, Zhou, and Hero (<a href="#ref-TeraLasso" role="doc-biblioref">2017</a>)</span>:</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="./images/TeraLasso.png" class="img-fluid figure-img"></p>
<figcaption>The solution of <span class="citation" data-cites="TeraLasso">Greenewald, Zhou, and Hero (<a href="#ref-TeraLasso" role="doc-biblioref">2017</a>)</span>; details on the <span class="math inline">\(A(i,i|k)\)</span> matrices available in the TeraLasso paper.</figcaption>
</figure>
</div>
<p>We can calculate the <span class="math inline">\(A_k\)</span> as follows:</p>
<div id="bf5c7a23-5377-45da-b6b5-da2c5ff71747" class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb22"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> factorwise_average(</span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a>    mat: <span class="st">"Mat to be factored"</span>,</span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a>    ds: <span class="st">"Dimensions of factor matrices"</span>,</span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a>    k: <span class="st">"Dimension"</span></span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true" tabindex="-1"></a>):</span>
<span id="cb22-6"><a href="#cb22-6" aria-hidden="true" tabindex="-1"></a>    d <span class="op">=</span> ds[k]</span>
<span id="cb22-7"><a href="#cb22-7" aria-hidden="true" tabindex="-1"></a>    d_left <span class="op">=</span> np.prod(ds[:k]).astype(<span class="bu">int</span>)</span>
<span id="cb22-8"><a href="#cb22-8" aria-hidden="true" tabindex="-1"></a>    d_right <span class="op">=</span> np.prod(ds[k<span class="op">+</span><span class="dv">1</span>:]).astype(<span class="bu">int</span>)</span>
<span id="cb22-9"><a href="#cb22-9" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb22-10"><a href="#cb22-10" aria-hidden="true" tabindex="-1"></a>    rs, cs <span class="op">=</span> mat.strides</span>
<span id="cb22-11"><a href="#cb22-11" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb22-12"><a href="#cb22-12" aria-hidden="true" tabindex="-1"></a>    <span class="co"># See code for `factorwise_matrix` for full A(i,j|k) computation</span></span>
<span id="cb22-13"><a href="#cb22-13" aria-hidden="true" tabindex="-1"></a>    <span class="co"># (in the Playground section at the end)</span></span>
<span id="cb22-14"><a href="#cb22-14" aria-hidden="true" tabindex="-1"></a>    <span class="co"># But here we only need the diagonals so actually we can express this</span></span>
<span id="cb22-15"><a href="#cb22-15" aria-hidden="true" tabindex="-1"></a>    <span class="co"># by summing the strides together (so each stride goes the length of</span></span>
<span id="cb22-16"><a href="#cb22-16" aria-hidden="true" tabindex="-1"></a>    <span class="co"># an axis plus 1 to stay along the diagonal</span></span>
<span id="cb22-17"><a href="#cb22-17" aria-hidden="true" tabindex="-1"></a>    out <span class="op">=</span>  np.lib.stride_tricks.as_strided(</span>
<span id="cb22-18"><a href="#cb22-18" aria-hidden="true" tabindex="-1"></a>        mat,</span>
<span id="cb22-19"><a href="#cb22-19" aria-hidden="true" tabindex="-1"></a>        shape<span class="op">=</span>(</span>
<span id="cb22-20"><a href="#cb22-20" aria-hidden="true" tabindex="-1"></a>            d_left,</span>
<span id="cb22-21"><a href="#cb22-21" aria-hidden="true" tabindex="-1"></a>            d_right,</span>
<span id="cb22-22"><a href="#cb22-22" aria-hidden="true" tabindex="-1"></a>            d,</span>
<span id="cb22-23"><a href="#cb22-23" aria-hidden="true" tabindex="-1"></a>            d</span>
<span id="cb22-24"><a href="#cb22-24" aria-hidden="true" tabindex="-1"></a>        ),</span>
<span id="cb22-25"><a href="#cb22-25" aria-hidden="true" tabindex="-1"></a>        strides<span class="op">=</span>(</span>
<span id="cb22-26"><a href="#cb22-26" aria-hidden="true" tabindex="-1"></a>            rs <span class="op">*</span> d_right <span class="op">*</span> d <span class="op">+</span> cs <span class="op">*</span> d_right <span class="op">*</span> d,</span>
<span id="cb22-27"><a href="#cb22-27" aria-hidden="true" tabindex="-1"></a>            rs <span class="op">*</span> <span class="dv">1</span> <span class="op">+</span> cs <span class="op">*</span> <span class="dv">1</span>,</span>
<span id="cb22-28"><a href="#cb22-28" aria-hidden="true" tabindex="-1"></a>            rs <span class="op">*</span> d_right,</span>
<span id="cb22-29"><a href="#cb22-29" aria-hidden="true" tabindex="-1"></a>            cs <span class="op">*</span> d_right,</span>
<span id="cb22-30"><a href="#cb22-30" aria-hidden="true" tabindex="-1"></a>        )</span>
<span id="cb22-31"><a href="#cb22-31" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb22-32"><a href="#cb22-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-33"><a href="#cb22-33" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> out.mean(axis<span class="op">=</span>(<span class="dv">0</span>, <span class="dv">1</span>))</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</div>
<p>After which it is easy to compute individual factors:</p>
<div id="e8633197-c18d-4375-893e-1ba93ec54e3c" class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb23"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> kronecker_factor(</span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a>    mat: <span class="st">"Mat to be factored"</span>,</span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a>    ds: <span class="st">"Dimensions of factor matrices"</span>,</span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true" tabindex="-1"></a>    k: <span class="st">"Dimension"</span></span>
<span id="cb23-5"><a href="#cb23-5" aria-hidden="true" tabindex="-1"></a>):</span>
<span id="cb23-6"><a href="#cb23-6" aria-hidden="true" tabindex="-1"></a>    K <span class="op">=</span> <span class="bu">len</span>(ds)</span>
<span id="cb23-7"><a href="#cb23-7" aria-hidden="true" tabindex="-1"></a>    A <span class="op">=</span> factorwise_average(mat, ds, k)</span>
<span id="cb23-8"><a href="#cb23-8" aria-hidden="true" tabindex="-1"></a>    offset <span class="op">=</span> (K<span class="op">-</span><span class="dv">1</span>)<span class="op">/</span>K <span class="op">*</span> np.trace(A) <span class="op">/</span> ds[k]</span>
<span id="cb23-9"><a href="#cb23-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> A <span class="op">-</span> offset <span class="op">*</span> np.eye(A.shape[<span class="dv">0</span>])</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</div>
<p>One thing to note about their math is that they assume the factors have a trace of zero (because it is not actually possible to recover the exact diagonals in a <b style="color:#537FBF">KS-decomposition</b>). Let’s test to see if it actually can recover the factors:</p>
<div id="1dace09d-09a5-422e-9d31-a07a2343001a" class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb24"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Subtractions are done to enforce a trace of zero</span></span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a>factor_1 <span class="op">=</span> np.arange(<span class="dv">9</span>).reshape(<span class="dv">3</span>, <span class="dv">3</span>) <span class="op">-</span> <span class="dv">4</span></span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a>factor_2 <span class="op">=</span> np.arange(<span class="dv">4</span>).reshape(<span class="dv">2</span>, <span class="dv">2</span>) <span class="op">-</span> <span class="fl">1.5</span></span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true" tabindex="-1"></a>b <span class="op">=</span> kron_sum(factor_1, factor_2)</span>
<span id="cb24-5"><a href="#cb24-5" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(factor_1 <span class="op">==</span> kronecker_factor(b, [<span class="dv">3</span>, <span class="dv">2</span>], <span class="dv">0</span>))</span>
<span id="cb24-6"><a href="#cb24-6" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(factor_2 <span class="op">==</span> kronecker_factor(b, [<span class="dv">3</span>, <span class="dv">2</span>], <span class="dv">1</span>))</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-stdout">
<pre><code>[[ True  True  True]
 [ True  True  True]
 [ True  True  True]]
[[ True  True]
 [ True  True]]</code></pre>
</div>
</div>
<p>Awesome! But as mentioned before, we often only care about <b style="color:#537FBF">KS-decomposing</b> diagonal matrices, so we can tune this code to address them specifically!</p>
<div id="851b39bf-72fa-4d7b-88a1-40d870af2350" class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb26"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> factorwise_average_diag(</span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a>    vec: <span class="st">"Diagonal of mat to be factored"</span>,</span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a>    ds: <span class="st">"Dimensions of factor matrices"</span>,</span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true" tabindex="-1"></a>    k: <span class="st">"Dimension"</span></span>
<span id="cb26-5"><a href="#cb26-5" aria-hidden="true" tabindex="-1"></a>):</span>
<span id="cb26-6"><a href="#cb26-6" aria-hidden="true" tabindex="-1"></a>    d <span class="op">=</span> ds[k]</span>
<span id="cb26-7"><a href="#cb26-7" aria-hidden="true" tabindex="-1"></a>    d_left <span class="op">=</span> np.prod(ds[:k]).astype(<span class="bu">int</span>)</span>
<span id="cb26-8"><a href="#cb26-8" aria-hidden="true" tabindex="-1"></a>    d_right <span class="op">=</span> np.prod(ds[k<span class="op">+</span><span class="dv">1</span>:]).astype(<span class="bu">int</span>)</span>
<span id="cb26-9"><a href="#cb26-9" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb26-10"><a href="#cb26-10" aria-hidden="true" tabindex="-1"></a>    rs <span class="op">=</span> vec.strides[<span class="dv">0</span>]</span>
<span id="cb26-11"><a href="#cb26-11" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb26-12"><a href="#cb26-12" aria-hidden="true" tabindex="-1"></a>    <span class="co"># See code for `factorwise_matrix` for full A(i,j|k) computation</span></span>
<span id="cb26-13"><a href="#cb26-13" aria-hidden="true" tabindex="-1"></a>    <span class="co"># (in the Playground section at the end)</span></span>
<span id="cb26-14"><a href="#cb26-14" aria-hidden="true" tabindex="-1"></a>    <span class="co"># But here we only need the diagonals so actually we can express this</span></span>
<span id="cb26-15"><a href="#cb26-15" aria-hidden="true" tabindex="-1"></a>    <span class="co"># by summing the strides together (so each stride goes the length of</span></span>
<span id="cb26-16"><a href="#cb26-16" aria-hidden="true" tabindex="-1"></a>    <span class="co"># an axis plus 1 to stay along the diagonal</span></span>
<span id="cb26-17"><a href="#cb26-17" aria-hidden="true" tabindex="-1"></a>    out <span class="op">=</span>  np.lib.stride_tricks.as_strided(</span>
<span id="cb26-18"><a href="#cb26-18" aria-hidden="true" tabindex="-1"></a>        vec,</span>
<span id="cb26-19"><a href="#cb26-19" aria-hidden="true" tabindex="-1"></a>        shape<span class="op">=</span>(</span>
<span id="cb26-20"><a href="#cb26-20" aria-hidden="true" tabindex="-1"></a>            d_left,</span>
<span id="cb26-21"><a href="#cb26-21" aria-hidden="true" tabindex="-1"></a>            d_right,</span>
<span id="cb26-22"><a href="#cb26-22" aria-hidden="true" tabindex="-1"></a>            d,</span>
<span id="cb26-23"><a href="#cb26-23" aria-hidden="true" tabindex="-1"></a>        ),</span>
<span id="cb26-24"><a href="#cb26-24" aria-hidden="true" tabindex="-1"></a>        strides<span class="op">=</span>(</span>
<span id="cb26-25"><a href="#cb26-25" aria-hidden="true" tabindex="-1"></a>            rs <span class="op">*</span> d_right <span class="op">*</span> d,</span>
<span id="cb26-26"><a href="#cb26-26" aria-hidden="true" tabindex="-1"></a>            rs <span class="op">*</span> <span class="dv">1</span>,</span>
<span id="cb26-27"><a href="#cb26-27" aria-hidden="true" tabindex="-1"></a>            rs <span class="op">*</span> d_right,</span>
<span id="cb26-28"><a href="#cb26-28" aria-hidden="true" tabindex="-1"></a>        )</span>
<span id="cb26-29"><a href="#cb26-29" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb26-30"><a href="#cb26-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-31"><a href="#cb26-31" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> out.mean(axis<span class="op">=</span>(<span class="dv">0</span>, <span class="dv">1</span>))</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</div>
<div id="744ce5d2-0f95-4a38-9528-b10ea673aa33" class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb27"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> kronecker_factor_diag(</span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a>    vec: <span class="st">"Diag of mat to be factored"</span>,</span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a>    ds: <span class="st">"Dimensions of factor matrices"</span>,</span>
<span id="cb27-4"><a href="#cb27-4" aria-hidden="true" tabindex="-1"></a>    k: <span class="st">"Dimension"</span></span>
<span id="cb27-5"><a href="#cb27-5" aria-hidden="true" tabindex="-1"></a>):</span>
<span id="cb27-6"><a href="#cb27-6" aria-hidden="true" tabindex="-1"></a>    K <span class="op">=</span> <span class="bu">len</span>(ds)</span>
<span id="cb27-7"><a href="#cb27-7" aria-hidden="true" tabindex="-1"></a>    A <span class="op">=</span> factorwise_average_diag(vec, ds, k)</span>
<span id="cb27-8"><a href="#cb27-8" aria-hidden="true" tabindex="-1"></a>    offset <span class="op">=</span> (K<span class="op">-</span><span class="dv">1</span>)<span class="op">/</span>K <span class="op">*</span> A.<span class="bu">sum</span>() <span class="op">/</span> ds[k]</span>
<span id="cb27-9"><a href="#cb27-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> A <span class="op">-</span> offset</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</div>
<div id="7b8a51db-9487-4e2a-a4e1-5e045f789f0f" class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb28"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a>d_1 <span class="op">=</span> <span class="dv">50</span></span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a>d_2 <span class="op">=</span> <span class="dv">100</span></span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true" tabindex="-1"></a>d_3 <span class="op">=</span> <span class="dv">150</span></span>
<span id="cb28-4"><a href="#cb28-4" aria-hidden="true" tabindex="-1"></a>factor_1 <span class="op">=</span> np.arange(d_1).astype(<span class="bu">float</span>)</span>
<span id="cb28-5"><a href="#cb28-5" aria-hidden="true" tabindex="-1"></a>factor_1 <span class="op">-=</span> factor_1.<span class="bu">sum</span>() <span class="op">/</span> d_1</span>
<span id="cb28-6"><a href="#cb28-6" aria-hidden="true" tabindex="-1"></a>factor_2 <span class="op">=</span> np.arange(d_2).astype(<span class="bu">float</span>)</span>
<span id="cb28-7"><a href="#cb28-7" aria-hidden="true" tabindex="-1"></a>factor_2 <span class="op">-=</span> factor_2.<span class="bu">sum</span>() <span class="op">/</span> d_2</span>
<span id="cb28-8"><a href="#cb28-8" aria-hidden="true" tabindex="-1"></a>factor_3 <span class="op">=</span> np.arange(d_3).astype(<span class="bu">float</span>)</span>
<span id="cb28-9"><a href="#cb28-9" aria-hidden="true" tabindex="-1"></a>factor_3 <span class="op">-=</span> factor_3.<span class="bu">sum</span>() <span class="op">/</span> d_3</span>
<span id="cb28-10"><a href="#cb28-10" aria-hidden="true" tabindex="-1"></a>b <span class="op">=</span> kron_sum_diag_fast(factor_1, factor_2, factor_3)</span>
<span id="cb28-11"><a href="#cb28-11" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>((factor_1 <span class="op">==</span> kronecker_factor_diag(b, [d_1, d_2, d_3], <span class="dv">0</span>)).<span class="bu">all</span>())</span>
<span id="cb28-12"><a href="#cb28-12" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>((factor_2 <span class="op">==</span> kronecker_factor_diag(b, [d_1, d_2, d_3], <span class="dv">1</span>)).<span class="bu">all</span>())</span>
<span id="cb28-13"><a href="#cb28-13" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>((factor_3 <span class="op">==</span> kronecker_factor_diag(b, [d_1, d_2, d_3], <span class="dv">2</span>)).<span class="bu">all</span>())</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-stdout">
<pre><code>True
True
True</code></pre>
</div>
</div>
<p>The last question we should ask is: is our code fast?</p>
<div id="a4737001-652f-488b-9f1f-1eb6670d88f9" class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb30"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a>to_run <span class="op">=</span> <span class="kw">lambda</span>: [</span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a>    kronecker_factor_diag(b, [d_1, d_2, d_3], <span class="dv">0</span>),</span>
<span id="cb30-3"><a href="#cb30-3" aria-hidden="true" tabindex="-1"></a>    kronecker_factor_diag(b, [d_1, d_2, d_3], <span class="dv">1</span>),</span>
<span id="cb30-4"><a href="#cb30-4" aria-hidden="true" tabindex="-1"></a>    kronecker_factor_diag(b, [d_1, d_2, d_3], <span class="dv">2</span>)</span>
<span id="cb30-5"><a href="#cb30-5" aria-hidden="true" tabindex="-1"></a>]</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-stdout">
<pre><code>643 µs ± 10.2 µs per loop (mean ± std. dev. of 7 runs, 1,000 loops each)</code></pre>
</div>
</div>
<div id="14589eaa-eac6-4d14-99ad-03f8ea5a2f75" class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb32"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-display">
<pre><code>Timer unit: 1e-06 s

Total time: 0.00126 s
File: /var/folders/k0/qy74mdx10qs493700g929k5h0000gn/T/ipykernel_36281/1788147058.py
Function: &lt;lambda&gt; at line 1

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
     1         1          1.0      1.0      0.1  to_run = lambda: [
     2         1        547.0    547.0     43.4      kronecker_factor_diag(b, [d_1, d_2, d_3], 0),
     3         1        366.0    366.0     29.0      kronecker_factor_diag(b, [d_1, d_2, d_3], 1),
     4         1        346.0    346.0     27.5      kronecker_factor_diag(b, [d_1, d_2, d_3], 2)
     5                                           ]

Total time: 0.001157 s
File: /var/folders/k0/qy74mdx10qs493700g929k5h0000gn/T/ipykernel_36281/1895741134.py
Function: factorwise_average_diag at line 1

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
     1                                           def factorwise_average_diag(
     2                                               vec: "Diagonal of mat to be factored",
     3                                               ds: "Dimensions of factor matrices",
     4                                               k: "Dimension"
     5                                           ):
     6         3          3.0      1.0      0.3      d = ds[k]
     7         3        103.0     34.3      8.9      d_left = np.prod(ds[:k]).astype(int)
     8         3         44.0     14.7      3.8      d_right = np.prod(ds[k+1:]).astype(int)
     9                                               
    10         3          4.0      1.3      0.3      rs = vec.strides[0]
    11                                               
    12                                               # See code for `factorwise_matrix` for full A(i,j|k) computation
    13                                               # (in the Playground section at the end)
    14                                               # But here we only need the diagonals so actually we can express this
    15                                               # by summing the strides together (so each stride goes the length of
    16                                               # an axis plus 1 to stay along the diagonal
    17         6         62.0     10.3      5.4      out =  np.lib.stride_tricks.as_strided(
    18         3          0.0      0.0      0.0          vec,
    19         3          2.0      0.7      0.2          shape=(
    20         3          2.0      0.7      0.2              d_left,
    21         3          2.0      0.7      0.2              d_right,
    22         3          2.0      0.7      0.2              d,
    23                                                   ),
    24         3          3.0      1.0      0.3          strides=(
    25         3          5.0      1.7      0.4              rs * d_right * d,
    26         3          3.0      1.0      0.3              rs * 1,
    27         3          3.0      1.0      0.3              rs * d_right,
    28                                                   )
    29                                               )
    30                                           
    31         3        919.0    306.3     79.4      return out.mean(axis=(0, 1))

Total time: 0.001231 s
File: /var/folders/k0/qy74mdx10qs493700g929k5h0000gn/T/ipykernel_36281/494531187.py
Function: kronecker_factor_diag at line 1

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
     1                                           def kronecker_factor_diag(
     2                                               vec: "Diag of mat to be factored",
     3                                               ds: "Dimensions of factor matrices",
     4                                               k: "Dimension"
     5                                           ):
     6         3          1.0      0.3      0.1      K = len(ds)
     7         3       1190.0    396.7     96.7      A = factorwise_average_diag(vec, ds, k)
     8         3         25.0      8.3      2.0      offset = (K-1)/K * A.sum() / ds[k]
     9         3         15.0      5.0      1.2      return A - offset</code></pre>
</div>
</div>
<p>Well, it seems pretty fast as it’s measured in microseconds. Basically all the runtime is in taking the mean along the axes. Since we’re computing each factor separately, there may be a really smart way to compute these means jointly to save time. However if we note that the calls to <code>np.prod</code> take up ~10% of the runtime, and realize just how cheap that option ‘should’ be<a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a>, we shouldn’t expect to be able to get more than an order of magnitude improvement no matter what we do<a href="#fn4" class="footnote-ref" id="fnref4" role="doc-noteref"><sup>4</sup></a>.</p>
<p>The datasets I’ll be using this for won’t really exceed 4000 by 4000, as memory constaints prevent much more (this is part of a larger algorithm whose outputs for 4000 by 4000 inputs would be size <span class="math inline">\(2 * 4000^2 = 128 \hspace{2pt}\mathrm{megabytes}\)</span> assuming 32-bit floats); quite hefty! Also the algorithm would require an eigendecomposition on two 4000 by 4000 matrices, which takes more than a minute on my computer which is more than I have the patience for 😅 .</p>
<div id="422940bb-5867-46a1-8609-c9b8d0ca9d4e" class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb34"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a>d_1 <span class="op">=</span> <span class="dv">4000</span></span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true" tabindex="-1"></a>d_2 <span class="op">=</span> <span class="dv">4000</span></span>
<span id="cb34-3"><a href="#cb34-3" aria-hidden="true" tabindex="-1"></a>factor_1 <span class="op">=</span> np.arange(d_1).astype(<span class="bu">float</span>)</span>
<span id="cb34-4"><a href="#cb34-4" aria-hidden="true" tabindex="-1"></a>factor_1 <span class="op">-=</span> factor_1.<span class="bu">sum</span>() <span class="op">/</span> d_1</span>
<span id="cb34-5"><a href="#cb34-5" aria-hidden="true" tabindex="-1"></a>factor_2 <span class="op">=</span> np.arange(d_2).astype(<span class="bu">float</span>)</span>
<span id="cb34-6"><a href="#cb34-6" aria-hidden="true" tabindex="-1"></a>factor_2 <span class="op">-=</span> factor_2.<span class="bu">sum</span>() <span class="op">/</span> d_2</span>
<span id="cb34-7"><a href="#cb34-7" aria-hidden="true" tabindex="-1"></a>c <span class="op">=</span> kron_sum_diag_fast(factor_1, factor_2)</span>
<span id="cb34-8"><a href="#cb34-8" aria-hidden="true" tabindex="-1"></a>to_run <span class="op">=</span> <span class="kw">lambda</span>: [</span>
<span id="cb34-9"><a href="#cb34-9" aria-hidden="true" tabindex="-1"></a>    kronecker_factor_diag(b, [d_1, d_2], <span class="dv">0</span>),</span>
<span id="cb34-10"><a href="#cb34-10" aria-hidden="true" tabindex="-1"></a>    kronecker_factor_diag(b, [d_1, d_2], <span class="dv">1</span>),</span>
<span id="cb34-11"><a href="#cb34-11" aria-hidden="true" tabindex="-1"></a>]</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-stdout">
<pre><code>7.23 ms ± 94.3 µs per loop (mean ± std. dev. of 7 runs, 100 loops each)</code></pre>
</div>
</div>
<p>Thus in the largest input we’re considering, we can run this step 100 times a second, i.e.&nbsp;6000 times before it catches up to the price of an eigendecomposition. That’s good because our algorithm is iterative so we want to ensure it can be run a large amount of times!</p>
</section>
<section id="playground" class="level1">
<h1>Playground</h1>
<details>
<summary>
<b class="setups">Playground</b><b style="color:#C0CF96">: My experiments to get this to work</b>
</summary>
<p>Warning: I’ve made no attempt to clean this stuff up, or explain it whatsoever.</p>
<div id="78b590af-8c04-495b-8ec7-63df326aa17a" class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb36"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</div>
<p>Old code</p>
<pre><code>def factorwise_matrix(
    mat: "Mat to be factored",
    ds: "Dimensions of factor matrices",
    idx: "Indices",
    k: "Dimension"
):
    """
    A(i, j | k) notation from TeraLasso
    """
    
    # Stride-blocking based off of StackOverflow answer:
    # https://stackoverflow.com/a/8070716/10642078
    d = ds[k]
    d_left = np.prod(ds[:k]).astype(int)
    d_right = np.prod(ds[k+1:]).astype(int)
    size = d_left * d * d_right
    
    sz = mat.itemsize
    shape = (d * d_right, d * d_right, d_left, d_left)

    strides = sz * np.array([
        mat.shape[0] * d_left,
        d_left,
        mat.shape[0],
        1
    ])
    blocks = np.lib.stride_tricks.as_strided(mat, shape=shape, strides=strides)
    
    # Now that we've got the strides, we need to pick the right one based on the idxs
    i, j = idx
    
    # Last two dimensions are the sizes of the blocks
    specific_block =  blocks[i::d, j::d]
    
    # Now we need to de-stride the block
    return np.concatenate(
        np.concatenate(
            specific_block,
            axis=1
        ),
        axis=1
    )
    
n=12
m=12
a = np.arange(n*m).reshape(n,m)
print(a)
out = factorwise_matrix(a, [3, 2, 2], (0, 0), 0)

out</code></pre>
<div id="562e8ff5-2f8b-4cf1-b56f-7f63a8703583" class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb38"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> factorwise_matrix(</span>
<span id="cb38-2"><a href="#cb38-2" aria-hidden="true" tabindex="-1"></a>    mat: <span class="st">"Mat to be factored"</span>,</span>
<span id="cb38-3"><a href="#cb38-3" aria-hidden="true" tabindex="-1"></a>    ds: <span class="st">"Dimensions of factor matrices"</span>,</span>
<span id="cb38-4"><a href="#cb38-4" aria-hidden="true" tabindex="-1"></a>    idx: <span class="st">"Indices"</span>,</span>
<span id="cb38-5"><a href="#cb38-5" aria-hidden="true" tabindex="-1"></a>    k: <span class="st">"Dimension"</span></span>
<span id="cb38-6"><a href="#cb38-6" aria-hidden="true" tabindex="-1"></a>):</span>
<span id="cb38-7"><a href="#cb38-7" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb38-8"><a href="#cb38-8" aria-hidden="true" tabindex="-1"></a><span class="co">    A(i, j | k) notation from TeraLasso</span></span>
<span id="cb38-9"><a href="#cb38-9" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb38-10"><a href="#cb38-10" aria-hidden="true" tabindex="-1"></a>    i, j <span class="op">=</span> idx</span>
<span id="cb38-11"><a href="#cb38-11" aria-hidden="true" tabindex="-1"></a>    d <span class="op">=</span> ds[k]</span>
<span id="cb38-12"><a href="#cb38-12" aria-hidden="true" tabindex="-1"></a>    d_left <span class="op">=</span> np.prod(ds[:k]).astype(<span class="bu">int</span>)</span>
<span id="cb38-13"><a href="#cb38-13" aria-hidden="true" tabindex="-1"></a>    d_right <span class="op">=</span> np.prod(ds[k<span class="op">+</span><span class="dv">1</span>:]).astype(<span class="bu">int</span>)</span>
<span id="cb38-14"><a href="#cb38-14" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb38-15"><a href="#cb38-15" aria-hidden="true" tabindex="-1"></a>    <span class="co">#return mat[i*d::d_left, j*d::d_left][:d, :d]</span></span>
<span id="cb38-16"><a href="#cb38-16" aria-hidden="true" tabindex="-1"></a>    rs, cs <span class="op">=</span> mat.strides</span>
<span id="cb38-17"><a href="#cb38-17" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb38-18"><a href="#cb38-18" aria-hidden="true" tabindex="-1"></a>    out <span class="op">=</span>  np.lib.stride_tricks.as_strided(</span>
<span id="cb38-19"><a href="#cb38-19" aria-hidden="true" tabindex="-1"></a>        mat,</span>
<span id="cb38-20"><a href="#cb38-20" aria-hidden="true" tabindex="-1"></a>        shape<span class="op">=</span>(</span>
<span id="cb38-21"><a href="#cb38-21" aria-hidden="true" tabindex="-1"></a>            d_left,</span>
<span id="cb38-22"><a href="#cb38-22" aria-hidden="true" tabindex="-1"></a>            d_left,</span>
<span id="cb38-23"><a href="#cb38-23" aria-hidden="true" tabindex="-1"></a>            d_right,</span>
<span id="cb38-24"><a href="#cb38-24" aria-hidden="true" tabindex="-1"></a>            d_right,</span>
<span id="cb38-25"><a href="#cb38-25" aria-hidden="true" tabindex="-1"></a>            d,</span>
<span id="cb38-26"><a href="#cb38-26" aria-hidden="true" tabindex="-1"></a>            d</span>
<span id="cb38-27"><a href="#cb38-27" aria-hidden="true" tabindex="-1"></a>        ),</span>
<span id="cb38-28"><a href="#cb38-28" aria-hidden="true" tabindex="-1"></a>        strides<span class="op">=</span>(</span>
<span id="cb38-29"><a href="#cb38-29" aria-hidden="true" tabindex="-1"></a>            rs <span class="op">*</span> d_right <span class="op">*</span> d,</span>
<span id="cb38-30"><a href="#cb38-30" aria-hidden="true" tabindex="-1"></a>            cs <span class="op">*</span> d_right <span class="op">*</span> d,</span>
<span id="cb38-31"><a href="#cb38-31" aria-hidden="true" tabindex="-1"></a>            rs <span class="op">*</span> <span class="dv">1</span>,</span>
<span id="cb38-32"><a href="#cb38-32" aria-hidden="true" tabindex="-1"></a>            cs <span class="op">*</span> <span class="dv">1</span>,</span>
<span id="cb38-33"><a href="#cb38-33" aria-hidden="true" tabindex="-1"></a>            rs <span class="op">*</span> d_right,</span>
<span id="cb38-34"><a href="#cb38-34" aria-hidden="true" tabindex="-1"></a>            cs <span class="op">*</span> d_right,</span>
<span id="cb38-35"><a href="#cb38-35" aria-hidden="true" tabindex="-1"></a>        )</span>
<span id="cb38-36"><a href="#cb38-36" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb38-37"><a href="#cb38-37" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb38-38"><a href="#cb38-38" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> out</span>
<span id="cb38-39"><a href="#cb38-39" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb38-40"><a href="#cb38-40" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb38-41"><a href="#cb38-41" aria-hidden="true" tabindex="-1"></a>n<span class="op">=</span><span class="dv">12</span></span>
<span id="cb38-42"><a href="#cb38-42" aria-hidden="true" tabindex="-1"></a>m<span class="op">=</span><span class="dv">12</span></span>
<span id="cb38-43"><a href="#cb38-43" aria-hidden="true" tabindex="-1"></a>a <span class="op">=</span> np.arange(n<span class="op">*</span>m).reshape(n,m)</span>
<span id="cb38-44"><a href="#cb38-44" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(a)</span>
<span id="cb38-45"><a href="#cb38-45" aria-hidden="true" tabindex="-1"></a>out <span class="op">=</span> factorwise_matrix(a, [<span class="dv">3</span>, <span class="dv">2</span>, <span class="dv">2</span>], (<span class="dv">0</span>, <span class="dv">0</span>), <span class="dv">1</span>)</span>
<span id="cb38-46"><a href="#cb38-46" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-47"><a href="#cb38-47" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(out.shape)</span>
<span id="cb38-48"><a href="#cb38-48" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(out.strides)</span>
<span id="cb38-49"><a href="#cb38-49" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(out.<span class="bu">sum</span>() <span class="op">==</span> a.<span class="bu">sum</span>())</span>
<span id="cb38-50"><a href="#cb38-50" aria-hidden="true" tabindex="-1"></a><span class="co">#out</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-stdout">
<pre><code>[[  0   1   2   3   4   5   6   7   8   9  10  11]
 [ 12  13  14  15  16  17  18  19  20  21  22  23]
 [ 24  25  26  27  28  29  30  31  32  33  34  35]
 [ 36  37  38  39  40  41  42  43  44  45  46  47]
 [ 48  49  50  51  52  53  54  55  56  57  58  59]
 [ 60  61  62  63  64  65  66  67  68  69  70  71]
 [ 72  73  74  75  76  77  78  79  80  81  82  83]
 [ 84  85  86  87  88  89  90  91  92  93  94  95]
 [ 96  97  98  99 100 101 102 103 104 105 106 107]
 [108 109 110 111 112 113 114 115 116 117 118 119]
 [120 121 122 123 124 125 126 127 128 129 130 131]
 [132 133 134 135 136 137 138 139 140 141 142 143]]
(3, 3, 2, 2, 2, 2)
(384, 32, 96, 8, 192, 16)
True</code></pre>
</div>
</div>
<pre><code>def factorwise_average(
    mat: "Mat to be factored",
    ds: "Dimensions of factor matrices",
    k: "Dimension"
):
    d = ds[k]
    d_left = np.prod(ds[:k]).astype(int)
    d_right = np.prod(ds[k+1:]).astype(int)
    d_non = d_left * d_right
    out = np.zeros((d, d))
    for i in range(d_non):
        out += factorwise_matrix(mat, ds, (i, i), k)
    return out / d_non
factorwise_average(a, [2, 2, 2], 1)</code></pre>
<div id="1ed49578-3a5b-438c-a198-8959e7ab1c2f" class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb41"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb41-1"><a href="#cb41-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> factorwise_average(</span>
<span id="cb41-2"><a href="#cb41-2" aria-hidden="true" tabindex="-1"></a>    mat: <span class="st">"Mat to be factored"</span>,</span>
<span id="cb41-3"><a href="#cb41-3" aria-hidden="true" tabindex="-1"></a>    ds: <span class="st">"Dimensions of factor matrices"</span>,</span>
<span id="cb41-4"><a href="#cb41-4" aria-hidden="true" tabindex="-1"></a>    k: <span class="st">"Dimension"</span></span>
<span id="cb41-5"><a href="#cb41-5" aria-hidden="true" tabindex="-1"></a>):</span>
<span id="cb41-6"><a href="#cb41-6" aria-hidden="true" tabindex="-1"></a>    d <span class="op">=</span> ds[k]</span>
<span id="cb41-7"><a href="#cb41-7" aria-hidden="true" tabindex="-1"></a>    d_left <span class="op">=</span> np.prod(ds[:k]).astype(<span class="bu">int</span>)</span>
<span id="cb41-8"><a href="#cb41-8" aria-hidden="true" tabindex="-1"></a>    d_right <span class="op">=</span> np.prod(ds[k<span class="op">+</span><span class="dv">1</span>:]).astype(<span class="bu">int</span>)</span>
<span id="cb41-9"><a href="#cb41-9" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb41-10"><a href="#cb41-10" aria-hidden="true" tabindex="-1"></a>    rs, cs <span class="op">=</span> mat.strides</span>
<span id="cb41-11"><a href="#cb41-11" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb41-12"><a href="#cb41-12" aria-hidden="true" tabindex="-1"></a>    <span class="co"># See code for `factorwise_matrix` for full A(i,j|k) computation</span></span>
<span id="cb41-13"><a href="#cb41-13" aria-hidden="true" tabindex="-1"></a>    <span class="co"># But here we only need the diagonals so actually we can express this</span></span>
<span id="cb41-14"><a href="#cb41-14" aria-hidden="true" tabindex="-1"></a>    <span class="co"># by summing the strides together (so each stride goes the length of</span></span>
<span id="cb41-15"><a href="#cb41-15" aria-hidden="true" tabindex="-1"></a>    <span class="co"># an axis plus 1 to stay along the diagonal</span></span>
<span id="cb41-16"><a href="#cb41-16" aria-hidden="true" tabindex="-1"></a>    out <span class="op">=</span>  np.lib.stride_tricks.as_strided(</span>
<span id="cb41-17"><a href="#cb41-17" aria-hidden="true" tabindex="-1"></a>        mat,</span>
<span id="cb41-18"><a href="#cb41-18" aria-hidden="true" tabindex="-1"></a>        shape<span class="op">=</span>(</span>
<span id="cb41-19"><a href="#cb41-19" aria-hidden="true" tabindex="-1"></a>            d_left,</span>
<span id="cb41-20"><a href="#cb41-20" aria-hidden="true" tabindex="-1"></a>            d_right,</span>
<span id="cb41-21"><a href="#cb41-21" aria-hidden="true" tabindex="-1"></a>            d,</span>
<span id="cb41-22"><a href="#cb41-22" aria-hidden="true" tabindex="-1"></a>            d</span>
<span id="cb41-23"><a href="#cb41-23" aria-hidden="true" tabindex="-1"></a>        ),</span>
<span id="cb41-24"><a href="#cb41-24" aria-hidden="true" tabindex="-1"></a>        strides<span class="op">=</span>(</span>
<span id="cb41-25"><a href="#cb41-25" aria-hidden="true" tabindex="-1"></a>            rs <span class="op">*</span> d_right <span class="op">*</span> d <span class="op">+</span> cs <span class="op">*</span> d_right <span class="op">*</span> d,</span>
<span id="cb41-26"><a href="#cb41-26" aria-hidden="true" tabindex="-1"></a>            rs <span class="op">*</span> <span class="dv">1</span> <span class="op">+</span> cs <span class="op">*</span> <span class="dv">1</span>,</span>
<span id="cb41-27"><a href="#cb41-27" aria-hidden="true" tabindex="-1"></a>            rs <span class="op">*</span> d_right,</span>
<span id="cb41-28"><a href="#cb41-28" aria-hidden="true" tabindex="-1"></a>            cs <span class="op">*</span> d_right,</span>
<span id="cb41-29"><a href="#cb41-29" aria-hidden="true" tabindex="-1"></a>        )</span>
<span id="cb41-30"><a href="#cb41-30" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb41-31"><a href="#cb41-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-32"><a href="#cb41-32" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> out.mean(axis<span class="op">=</span>(<span class="dv">0</span>, <span class="dv">1</span>))</span>
<span id="cb41-33"><a href="#cb41-33" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb41-34"><a href="#cb41-34" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb41-35"><a href="#cb41-35" aria-hidden="true" tabindex="-1"></a>n<span class="op">=</span><span class="dv">12</span></span>
<span id="cb41-36"><a href="#cb41-36" aria-hidden="true" tabindex="-1"></a>m<span class="op">=</span><span class="dv">12</span></span>
<span id="cb41-37"><a href="#cb41-37" aria-hidden="true" tabindex="-1"></a>a <span class="op">=</span> np.arange(n<span class="op">*</span>m).reshape(n,m)</span>
<span id="cb41-38"><a href="#cb41-38" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(a)</span>
<span id="cb41-39"><a href="#cb41-39" aria-hidden="true" tabindex="-1"></a>out <span class="op">=</span> factorwise_average(a, [<span class="dv">3</span>, <span class="dv">2</span>, <span class="dv">2</span>], <span class="dv">1</span>)</span>
<span id="cb41-40"><a href="#cb41-40" aria-hidden="true" tabindex="-1"></a>out</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-stdout">
<pre><code>[[  0   1   2   3   4   5   6   7   8   9  10  11]
 [ 12  13  14  15  16  17  18  19  20  21  22  23]
 [ 24  25  26  27  28  29  30  31  32  33  34  35]
 [ 36  37  38  39  40  41  42  43  44  45  46  47]
 [ 48  49  50  51  52  53  54  55  56  57  58  59]
 [ 60  61  62  63  64  65  66  67  68  69  70  71]
 [ 72  73  74  75  76  77  78  79  80  81  82  83]
 [ 84  85  86  87  88  89  90  91  92  93  94  95]
 [ 96  97  98  99 100 101 102 103 104 105 106 107]
 [108 109 110 111 112 113 114 115 116 117 118 119]
 [120 121 122 123 124 125 126 127 128 129 130 131]
 [132 133 134 135 136 137 138 139 140 141 142 143]]</code></pre>
</div>
<div class="cell-output cell-output-display">
<pre><code>array([[58.5, 60.5],
       [82.5, 84.5]])</code></pre>
</div>
</div>
<div id="4bffff92-cf28-471b-a5ee-b083a143d56a" class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb44"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb44-1"><a href="#cb44-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> kronecker_factor(</span>
<span id="cb44-2"><a href="#cb44-2" aria-hidden="true" tabindex="-1"></a>    mat: <span class="st">"Mat to be factored"</span>,</span>
<span id="cb44-3"><a href="#cb44-3" aria-hidden="true" tabindex="-1"></a>    ds: <span class="st">"Dimensions of factor matrices"</span>,</span>
<span id="cb44-4"><a href="#cb44-4" aria-hidden="true" tabindex="-1"></a>    k: <span class="st">"Dimension"</span></span>
<span id="cb44-5"><a href="#cb44-5" aria-hidden="true" tabindex="-1"></a>):</span>
<span id="cb44-6"><a href="#cb44-6" aria-hidden="true" tabindex="-1"></a>    K <span class="op">=</span> <span class="bu">len</span>(ds)</span>
<span id="cb44-7"><a href="#cb44-7" aria-hidden="true" tabindex="-1"></a>    A <span class="op">=</span> factorwise_average(mat, ds, k)</span>
<span id="cb44-8"><a href="#cb44-8" aria-hidden="true" tabindex="-1"></a>    offset <span class="op">=</span> (K<span class="op">-</span><span class="dv">1</span>)<span class="op">/</span>K <span class="op">*</span> np.trace(A) <span class="op">/</span> ds[k]</span>
<span id="cb44-9"><a href="#cb44-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> A <span class="op">-</span> offset <span class="op">*</span> np.eye(A.shape[<span class="dv">0</span>])</span>
<span id="cb44-10"><a href="#cb44-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb44-11"><a href="#cb44-11" aria-hidden="true" tabindex="-1"></a>kronecker_factor(a, [<span class="dv">2</span>, <span class="dv">2</span>, <span class="dv">2</span>], <span class="dv">1</span>)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-display">
<pre><code>array([[ 2.16666667, 34.5       ],
       [56.5       , 28.16666667]])</code></pre>
</div>
</div>
<div id="2eb66032-351e-4501-b376-39c35bcdcd9b" class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb46"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb46-1"><a href="#cb46-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> kron_sum(A, B):</span>
<span id="cb46-2"><a href="#cb46-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb46-3"><a href="#cb46-3" aria-hidden="true" tabindex="-1"></a><span class="co">    Computes the kronecker sum of two square input matrices</span></span>
<span id="cb46-4"><a href="#cb46-4" aria-hidden="true" tabindex="-1"></a><span class="co">    </span></span>
<span id="cb46-5"><a href="#cb46-5" aria-hidden="true" tabindex="-1"></a><span class="co">    Note: `scipy.sparse.kronsum` is a thing that would</span></span>
<span id="cb46-6"><a href="#cb46-6" aria-hidden="true" tabindex="-1"></a><span class="co">    be useful - but it seems that `scipy.sparse` is not</span></span>
<span id="cb46-7"><a href="#cb46-7" aria-hidden="true" tabindex="-1"></a><span class="co">    yet a mature library to use.</span></span>
<span id="cb46-8"><a href="#cb46-8" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb46-9"><a href="#cb46-9" aria-hidden="true" tabindex="-1"></a>    a, _ <span class="op">=</span> A.shape</span>
<span id="cb46-10"><a href="#cb46-10" aria-hidden="true" tabindex="-1"></a>    b, _ <span class="op">=</span> B.shape</span>
<span id="cb46-11"><a href="#cb46-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> np.kron(A, np.eye(b)) <span class="op">+</span> np.kron(np.eye(a), B)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</div>
<div id="09e33cd9-6731-4cb1-9341-836d05379d15" class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb47"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb47-1"><a href="#cb47-1" aria-hidden="true" tabindex="-1"></a>factor_1 <span class="op">=</span> np.arange(<span class="dv">9</span>).reshape(<span class="dv">3</span>, <span class="dv">3</span>) <span class="op">-</span> <span class="dv">4</span></span>
<span id="cb47-2"><a href="#cb47-2" aria-hidden="true" tabindex="-1"></a>factor_2 <span class="op">=</span> np.arange(<span class="dv">9</span>).reshape(<span class="dv">3</span>, <span class="dv">3</span>) <span class="op">-</span> <span class="dv">4</span></span>
<span id="cb47-3"><a href="#cb47-3" aria-hidden="true" tabindex="-1"></a>b <span class="op">=</span> kron_sum(factor_1, factor_2)</span>
<span id="cb47-4"><a href="#cb47-4" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(factor_1 <span class="op">==</span> kronecker_factor(b, [<span class="dv">3</span>, <span class="dv">3</span>], <span class="dv">0</span>))</span>
<span id="cb47-5"><a href="#cb47-5" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(factor_2 <span class="op">==</span> kronecker_factor(b, [<span class="dv">3</span>, <span class="dv">3</span>], <span class="dv">1</span>))</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-stdout">
<pre><code>[[ True  True  True]
 [ True  True  True]
 [ True  True  True]]
[[ True  True  True]
 [ True  True  True]
 [ True  True  True]]</code></pre>
</div>
</div>
<div id="4dbd4478-77bb-4246-9d1e-a9fbf55f7463" class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb49"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb49-1"><a href="#cb49-1" aria-hidden="true" tabindex="-1"></a>factor_1 <span class="op">=</span> np.arange(<span class="dv">9</span>).reshape(<span class="dv">3</span>, <span class="dv">3</span>) <span class="op">-</span> <span class="dv">4</span></span>
<span id="cb49-2"><a href="#cb49-2" aria-hidden="true" tabindex="-1"></a>factor_2 <span class="op">=</span> np.arange(<span class="dv">9</span>).reshape(<span class="dv">3</span>, <span class="dv">3</span>)</span>
<span id="cb49-3"><a href="#cb49-3" aria-hidden="true" tabindex="-1"></a>factor_2 <span class="op">=</span> factor_2 <span class="op">@</span> factor_2 <span class="op">-</span> <span class="dv">60</span></span>
<span id="cb49-4"><a href="#cb49-4" aria-hidden="true" tabindex="-1"></a>b <span class="op">=</span> kron_sum(factor_1, factor_2)</span>
<span id="cb49-5"><a href="#cb49-5" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(factor_1 <span class="op">==</span> kronecker_factor(b, [<span class="dv">3</span>, <span class="dv">3</span>], <span class="dv">0</span>))</span>
<span id="cb49-6"><a href="#cb49-6" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(factor_2 <span class="op">==</span> kronecker_factor(b, [<span class="dv">3</span>, <span class="dv">3</span>], <span class="dv">1</span>))</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-stdout">
<pre><code>[[ True  True  True]
 [ True  True  True]
 [ True  True  True]]
[[ True  True  True]
 [ True  True  True]
 [ True  True  True]]</code></pre>
</div>
</div>
<div id="6d4f27a1-a23f-4df6-a0f3-49e8d8b4881e" class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb51"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb51-1"><a href="#cb51-1" aria-hidden="true" tabindex="-1"></a>factor_1 <span class="op">=</span> np.arange(<span class="dv">9</span>).reshape(<span class="dv">3</span>, <span class="dv">3</span>) <span class="op">-</span> <span class="dv">4</span></span>
<span id="cb51-2"><a href="#cb51-2" aria-hidden="true" tabindex="-1"></a>factor_2 <span class="op">=</span> np.arange(<span class="dv">4</span>).reshape(<span class="dv">2</span>, <span class="dv">2</span>) <span class="op">-</span> <span class="fl">1.5</span></span>
<span id="cb51-3"><a href="#cb51-3" aria-hidden="true" tabindex="-1"></a>b <span class="op">=</span> kron_sum(factor_1, factor_2)</span>
<span id="cb51-4"><a href="#cb51-4" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(factor_1 <span class="op">==</span> kronecker_factor(b, [<span class="dv">3</span>, <span class="dv">2</span>], <span class="dv">0</span>))</span>
<span id="cb51-5"><a href="#cb51-5" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(factor_2 <span class="op">==</span> kronecker_factor(b, [<span class="dv">3</span>, <span class="dv">2</span>], <span class="dv">1</span>))</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-stdout">
<pre><code>[[ True  True  True]
 [ True  True  True]
 [ True  True  True]]
[[ True  True]
 [ True  True]]</code></pre>
</div>
</div>
<section id="fast-ks-diag" class="level2">
<h2 class="anchored" data-anchor-id="fast-ks-diag">Fast KS-Diag</h2>
<div id="d098881b-9eba-4e7e-9b2c-ecf080ee7657" class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb53"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb53-1"><a href="#cb53-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> kronsum_diag(</span>
<span id="cb53-2"><a href="#cb53-2" aria-hidden="true" tabindex="-1"></a>    <span class="op">*</span>lams: <span class="st">"1D vectors to be kronsummed"</span></span>
<span id="cb53-3"><a href="#cb53-3" aria-hidden="true" tabindex="-1"></a>):</span>
<span id="cb53-4"><a href="#cb53-4" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Setup</span></span>
<span id="cb53-5"><a href="#cb53-5" aria-hidden="true" tabindex="-1"></a>    ds <span class="op">=</span> [<span class="bu">len</span>(lam) <span class="cf">for</span> lam <span class="kw">in</span> lams]</span>
<span id="cb53-6"><a href="#cb53-6" aria-hidden="true" tabindex="-1"></a>    d_lefts <span class="op">=</span> np.cumprod([<span class="dv">1</span>] <span class="op">+</span> ds[:<span class="op">-</span><span class="dv">1</span>]).astype(<span class="bu">int</span>)</span>
<span id="cb53-7"><a href="#cb53-7" aria-hidden="true" tabindex="-1"></a>    d_rights <span class="op">=</span> np.cumprod([<span class="dv">1</span>] <span class="op">+</span> ds[::<span class="op">-</span><span class="dv">1</span>])[<span class="op">-</span><span class="dv">2</span>::<span class="op">-</span><span class="dv">1</span>].astype(<span class="bu">int</span>)</span>
<span id="cb53-8"><a href="#cb53-8" aria-hidden="true" tabindex="-1"></a>    total <span class="op">=</span> d_rights[<span class="dv">0</span>] <span class="op">*</span> ds[<span class="dv">0</span>]</span>
<span id="cb53-9"><a href="#cb53-9" aria-hidden="true" tabindex="-1"></a>    out <span class="op">=</span> np.zeros(total)</span>
<span id="cb53-10"><a href="#cb53-10" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb53-11"><a href="#cb53-11" aria-hidden="true" tabindex="-1"></a>    <span class="co"># We're gonna be really naughty here and use stride_tricks</span></span>
<span id="cb53-12"><a href="#cb53-12" aria-hidden="true" tabindex="-1"></a>    <span class="co"># This is going to reshape our vector in a way so that the elements</span></span>
<span id="cb53-13"><a href="#cb53-13" aria-hidden="true" tabindex="-1"></a>    <span class="co"># we want to affect are batched by the first two dimensions</span></span>
<span id="cb53-14"><a href="#cb53-14" aria-hidden="true" tabindex="-1"></a>    <span class="co"># </span></span>
<span id="cb53-15"><a href="#cb53-15" aria-hidden="true" tabindex="-1"></a>    <span class="co"># This is because numpy's memory format doesn't directly support</span></span>
<span id="cb53-16"><a href="#cb53-16" aria-hidden="true" tabindex="-1"></a>    <span class="co"># block-strides, i.e. there's no direct way to grab:</span></span>
<span id="cb53-17"><a href="#cb53-17" aria-hidden="true" tabindex="-1"></a>    <span class="co"># [x x x x] x x x x [x x x x] x x x x</span></span>
<span id="cb53-18"><a href="#cb53-18" aria-hidden="true" tabindex="-1"></a>    <span class="co"># You can only either grab blocks:</span></span>
<span id="cb53-19"><a href="#cb53-19" aria-hidden="true" tabindex="-1"></a>    <span class="co"># [x x x x x x x x] x x x x x x x x</span></span>
<span id="cb53-20"><a href="#cb53-20" aria-hidden="true" tabindex="-1"></a>    <span class="co"># or strides:</span></span>
<span id="cb53-21"><a href="#cb53-21" aria-hidden="true" tabindex="-1"></a>    <span class="co"># [x] x [x] x [x] x [x] x [x] x [x] x [x] x [x] x [x] x [x] x</span></span>
<span id="cb53-22"><a href="#cb53-22" aria-hidden="true" tabindex="-1"></a>    <span class="co">#</span></span>
<span id="cb53-23"><a href="#cb53-23" aria-hidden="true" tabindex="-1"></a>    <span class="co"># But with stride_tricks we can massage the data</span></span>
<span id="cb53-24"><a href="#cb53-24" aria-hidden="true" tabindex="-1"></a>    <span class="co"># into a block-stride format, at the cost of an extra dimension,</span></span>
<span id="cb53-25"><a href="#cb53-25" aria-hidden="true" tabindex="-1"></a>    <span class="co"># via using a view (NOT a copy), making this quite</span></span>
<span id="cb53-26"><a href="#cb53-26" aria-hidden="true" tabindex="-1"></a>    <span class="co"># an efficient operation!</span></span>
<span id="cb53-27"><a href="#cb53-27" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(lams)):</span>
<span id="cb53-28"><a href="#cb53-28" aria-hidden="true" tabindex="-1"></a>        sz <span class="op">=</span> lams[i].strides[<span class="dv">0</span>]</span>
<span id="cb53-29"><a href="#cb53-29" aria-hidden="true" tabindex="-1"></a>        toset <span class="op">=</span> np.lib.stride_tricks.as_strided(</span>
<span id="cb53-30"><a href="#cb53-30" aria-hidden="true" tabindex="-1"></a>            out,</span>
<span id="cb53-31"><a href="#cb53-31" aria-hidden="true" tabindex="-1"></a>            shape<span class="op">=</span>(</span>
<span id="cb53-32"><a href="#cb53-32" aria-hidden="true" tabindex="-1"></a>                d_lefts[i], <span class="co"># The skips</span></span>
<span id="cb53-33"><a href="#cb53-33" aria-hidden="true" tabindex="-1"></a>                d_rights[i], <span class="co"># The blocks</span></span>
<span id="cb53-34"><a href="#cb53-34" aria-hidden="true" tabindex="-1"></a>                ds[i] <span class="co"># What we want</span></span>
<span id="cb53-35"><a href="#cb53-35" aria-hidden="true" tabindex="-1"></a>            ),</span>
<span id="cb53-36"><a href="#cb53-36" aria-hidden="true" tabindex="-1"></a>            strides<span class="op">=</span>(</span>
<span id="cb53-37"><a href="#cb53-37" aria-hidden="true" tabindex="-1"></a>                sz <span class="op">*</span> ds[i] <span class="op">*</span> d_rights[i],</span>
<span id="cb53-38"><a href="#cb53-38" aria-hidden="true" tabindex="-1"></a>                sz <span class="op">*</span> <span class="dv">1</span>,</span>
<span id="cb53-39"><a href="#cb53-39" aria-hidden="true" tabindex="-1"></a>                sz <span class="op">*</span> d_rights[i],</span>
<span id="cb53-40"><a href="#cb53-40" aria-hidden="true" tabindex="-1"></a>            )</span>
<span id="cb53-41"><a href="#cb53-41" aria-hidden="true" tabindex="-1"></a>        )</span>
<span id="cb53-42"><a href="#cb53-42" aria-hidden="true" tabindex="-1"></a>        toset <span class="op">+=</span> lams[i]</span>
<span id="cb53-43"><a href="#cb53-43" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb53-44"><a href="#cb53-44" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> out</span>
<span id="cb53-45"><a href="#cb53-45" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb53-46"><a href="#cb53-46" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb53-47"><a href="#cb53-47" aria-hidden="true" tabindex="-1"></a><span class="co"># This is indeed correct!</span></span>
<span id="cb53-48"><a href="#cb53-48" aria-hidden="true" tabindex="-1"></a><span class="co"># Checked by hand</span></span>
<span id="cb53-49"><a href="#cb53-49" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(kronsum_diag(</span>
<span id="cb53-50"><a href="#cb53-50" aria-hidden="true" tabindex="-1"></a>    np.arange(<span class="dv">2</span>),</span>
<span id="cb53-51"><a href="#cb53-51" aria-hidden="true" tabindex="-1"></a>    np.arange(<span class="dv">3</span>),</span>
<span id="cb53-52"><a href="#cb53-52" aria-hidden="true" tabindex="-1"></a>    np.arange(<span class="dv">4</span>)</span>
<span id="cb53-53"><a href="#cb53-53" aria-hidden="true" tabindex="-1"></a>))</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-stdout">
<pre><code>[0. 1. 2. 3. 1. 2. 3. 4. 2. 3. 4. 5. 1. 2. 3. 4. 2. 3. 4. 5. 3. 4. 5. 6.]</code></pre>
</div>
</div>
<div id="bb6dff6a-6054-450d-a3c8-2837d6135e9b" class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb55"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb55-1"><a href="#cb55-1" aria-hidden="true" tabindex="-1"></a><span class="co"># We can see that this operation is just about as fast as possible</span></span>
<span id="cb55-2"><a href="#cb55-2" aria-hidden="true" tabindex="-1"></a><span class="co"># Time is dominated by initialization and broadcasting</span></span>
<span id="cb55-3"><a href="#cb55-3" aria-hidden="true" tabindex="-1"></a><span class="co"># And consistently a couple percent of the time is taken by stride tricks</span></span>
<span id="cb55-4"><a href="#cb55-4" aria-hidden="true" tabindex="-1"></a><span class="co"># which is a basically free operation.</span></span>
<span id="cb55-5"><a href="#cb55-5" aria-hidden="true" tabindex="-1"></a><span class="co"># Can run 100-200 times a second on 100x100x100 data</span></span>
<span id="cb55-6"><a href="#cb55-6" aria-hidden="true" tabindex="-1"></a><span class="co"># And same for 1000x1000 data</span></span>
<span id="cb55-7"><a href="#cb55-7" aria-hidden="true" tabindex="-1"></a><span class="co"># And 500-1000 times a second on 100x100 data</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-display">
<pre><code>Timer unit: 1e-06 s

Total time: 0.005829 s
File: /var/folders/k0/qy74mdx10qs493700g929k5h0000gn/T/ipykernel_27579/3788467138.py
Function: kronsum_diag at line 1

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
     1                                           def kronsum_diag(
     2                                               *lams: "1D vectors to be kronsummed"
     3                                           ):
     4                                               # Setup
     5         1         26.0     26.0      0.4      ds = [len(lam) for lam in lams]
     6         1        132.0    132.0      2.3      d_lefts = np.cumprod([1] + ds[:-1]).astype(int)
     7         1         87.0     87.0      1.5      d_rights = np.cumprod([1] + ds[::-1])[-2::-1].astype(int)
     8         1         13.0     13.0      0.2      total = d_rights[0] * ds[0]
     9         1       1493.0   1493.0     25.6      out = np.zeros(total)
    10                                               
    11                                               # We're gonna be really naughty here and use stride_tricks
    12                                               # This is going to reshape our vector in a way so that the elements
    13                                               # we want to affect are batched by the first two dimensions
    14                                               # 
    15                                               # This is because numpy's memory format doesn't directly support
    16                                               # block-strides, i.e. there's no direct way to grab:
    17                                               # [x x x x] x x x x [x x x x] x x x x
    18                                               # You can only either grab blocks:
    19                                               # [x x x x x x x x] x x x x x x x x
    20                                               # or strides:
    21                                               # [x] x [x] x [x] x [x] x [x] x [x] x [x] x [x] x [x] x [x] x
    22                                               #
    23                                               # But with stride_tricks we can massage the data
    24                                               # into a block-stride format, at the cost of an extra dimension,
    25                                               # via using a view (NOT a copy), making this quite
    26                                               # an efficient operation!
    27         4         32.0      8.0      0.5      for i in range(len(lams)):
    28         3         19.0      6.3      0.3          sz = lams[i].strides[0]
    29         6        314.0     52.3      5.4          toset = np.lib.stride_tricks.as_strided(
    30         3          5.0      1.7      0.1              out,
    31         3          7.0      2.3      0.1              shape=(
    32         3         31.0     10.3      0.5                  d_lefts[i], # The skips
    33         3          7.0      2.3      0.1                  d_rights[i], # The blocks
    34         3          6.0      2.0      0.1                  ds[i] # What we want
    35                                                       ),
    36         3          4.0      1.3      0.1              strides=(
    37         3         20.0      6.7      0.3                  sz * ds[i] * d_rights[i],
    38         3          5.0      1.7      0.1                  sz * 1,
    39         3          6.0      2.0      0.1                  sz * d_rights[i],
    40                                                       )
    41                                                   )
    42         3       3620.0   1206.7     62.1          toset += lams[i]
    43                                                   
    44         1          2.0      2.0      0.0      return out</code></pre>
</div>
</div>
</section></details>



</section>



<div id="quarto-appendix" class="default"><section class="quarto-appendix-contents" role="doc-bibliography" id="quarto-bibliography"><h2 class="anchored quarto-appendix-heading">References</h2><div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0" role="list">
<div id="ref-TeraLasso" class="csl-entry" role="listitem">
Greenewald, Kristjan, Shuheng Zhou, and Alfred Hero. 2017. <span>“Tensor Graphical Lasso (TeraLasso).”</span> arXiv. <a href="https://doi.org/10.48550/ARXIV.1705.03983">https://doi.org/10.48550/ARXIV.1705.03983</a>.
</div>
</div></section><section id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes"><h2 class="anchored quarto-appendix-heading">Footnotes</h2>

<ol>
<li id="fn1"><p>Besides the memory of <b style="color:#A6A440">shape</b> and <b style="color:#A6A440">strides</b> themselves, but these are negligibly sized.<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2"><p>I know, I’m really pulling out all the stops in advanced NumPy - if only there was some way to get <code>einsum</code> involved…<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn3"><p>To be honest I expect there are some optimizations to be made here since the input list is so small (and the fact that it’s being passed as a list… And that the computation for these could be done jointly quite easily… etc…<a href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn4"><p>And we should expect much less since the raw amount of additions we have to do is quite large so there’s no way we’d get it down to the cost of an <code>np.prod</code>!<a href="#fnref4" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section></div></main> <!-- /main -->
<script>
    // Remove background
    elements = document.querySelectorAll('[id=clean-collapse]').forEach(
        function(element) {
            element.classList.remove("callout-style-default");
        }
    )
    
    // Add arrow to front to signify dropdownyness
    arrow = "▶";
    elements = document.querySelectorAll('.callout-caption-container').forEach(
        function(element) {
            element.innerHTML = arrow + element.innerHTML;
        }
    )
</script>
<script src="https://giscus.app/client.js" data-repo="baileyandrew/blog" data-repo-id="R_kgDOInJwKg" data-category="Announcements" data-category-id="DIC_kwDOInJwKs4CTGOQ" data-mapping="title" data-strict="0" data-reactions-enabled="1" data-emit-metadata="0" data-input-position="top" data-theme="dark_protanopia" data-lang="en" data-loading="lazy" crossorigin="anonymous" async="">
</script>
<!--
Assuming `_quarto.yml` has `navbar: pinned: true`,
this will make it so that the navbar scrolls with the rest of the website.
-->
<script>
    document.getElementById('quarto-header').classList.remove('fixed-top');
</script>
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
      const outerScaffold = trigger.parentElement.cloneNode(true);
      const codeEl = outerScaffold.querySelector('code');
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp("https:\/\/BaileyAndrew\.github\.io\/Blog");
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




<footer class="footer"><div class="nav-footer"><div class="nav-footer-center"><div class="toc-actions d-sm-block d-md-none"><ul><li><a href="https://github.com/BaileyAndrew/Blog/issues/new" class="toc-action"><i class="bi bi-github"></i>Report an issue</a></li></ul></div></div></div></footer></body></html>